# 6章 高度な型
## 6.7章 さらに高度な型
### 6.7.1 object型・never型

object型：プリミティブ型以外のすべて、を表す型
ただし、object型単体では使いにくい。object型だけではどんなプロパティを持っているかか不明なため、unknown型に近いような型とも言える。

```
// toStringを持つ値の型
type HasToString = {
  toString: () => string
}

function useToString1(value: HasToString) {
  console.log(`value is ${value.toString()}`);
}

useToString1({
  toString() {
    return 'foo';
  }
});

useToString(3.14);
```

HasToString型は `toString` メソッドをもつオブジェクト型を表すため、`toString` 関数を持つオブジェクト型だけでなく、数値やそのほかのプリミティブ型にも適用できる。

しかし、プリミティブ型が渡されると不都合な場合には、object型を用いて受け取る型を制限することができる。

```
type HasToString = {
  toString: () => string
};

function useToString2(value: HasToString & object) {
  console.log(`value is ${value.toString()}`);
}

useToString2({
  toString() {
    return 'foo';
  }
});

useToString(3.14); // error
```

never型は、unknown型の真逆にあたる存在で「当てはまる型が存在しない」という性質を持つ型。

```
function useNever(value: never) {
  const num: number = value;
  const str: string = value;
  const obj: object = value;
  console.log(`value is ${value}`);
  // never型は当てはまる型が存在しないので、どんな型にも当てはめることができる
};

useNever({}); // 一方で、never型に当てはめれる値は存在しないので、エラーになる
useNever(3.14);
```

never型を返す関数を作ることができる

```
function thrower(): never {
  throw new Error('error');
};

const result: never = thrower();

const str: string = result;
console.log(str);
```

関数throwerは呼び出すと必ずエラーを投げることから、戻り値を取ることができない。
エラーが発生すると大域脱出が発生するため、戻り値が存在しない。




### 6.7.2 型述語（ユーザー定義型ガード）

ユーザー定義型ガードとは、型の絞り込みを自由に行うためのしくみ。
型の絞り込み、ナローイングにはコンパイラーの限界があるためこの仕組みがある。
注意点としては、any や as と立ち位置が近いため、型安全を破壊するおそれを含んでいること。

ユーザー定義型ガードは戻り値の型として、型述語（ type predicates ）が書かれた特殊な関数。
型述語には２種類ある
- 引数名 is 型
- asserts 引数名 is 型

#### 引数名 is 型

```
function isStringOrNumber(value: unknown): value is string | number {
  return typeof value === "string" || typeof value === "number;
}

const something: unknown = 123;

if (isStringOrNumber(something)) {
  // somethingは string or number 型
  console.log(something.toString())
}
```

somethingはunknown型だったが、isStringOrNumber型を通すことで、string or number 型にナローイングできた


```
// 戻り値の型を `value is string | number` から `boolean` に変更
function isStringOrNumber(value: unknown): boolean {
  return typeof value === "string" || typeof value === "number;
}

const something: unknown = 123;

if (isStringOrNumber(something)) {
  // 型の絞り込みが行われたわけではないので、エラーが起きる
  console.log(something.toString())
}
```

ユーザー定義型ガードの危険な例

```
function isStringOrNumber(value: unknown): value is string | number {
  return typeof value === "string" || typeof value === "boolean";
}
```

戻り値の型述語は string | number だが、判定には boolean が用いられてしまっている


ユーザー定義型ガードの実践的な例

```
type Human = {
  type: "Human";
  name: string;
  age: number;
};

function isHuman(value: any): value is Human {
  if (value == null) return false;
  return (
    value.type === "Human" &&
    typeof value.name === "string" &&
    typeof value.age === "number
  )
}
```

与えられた値がHuman型を満たすかどうかを判定するユーザー定義型ガード。
引数をanyとしている箇所について、unknownが望ましいが、ユーザー定義型ガードを利用する時点で any でも unknown でも型安全性はどちらも変わらない点や、unknownにするとプロパティアクセスをするために一工夫必要になってしまうことがあるため、any としている


コラム、anyではなくunknownの場合
```
function is PropertyAccessible(value: unknown): value is { [key: string]: unknown } {
  return value != null;
};
function isHuman(value: any): value is Human {
  if (!PropertyAccessible(value)) return false;
  return (
    value.type === "Human" &&
    typeof value.name === "string" &&
    typeof value.age === "number
  )
}
```


#### asserts 引数名 is 型

この形が引数の返り値にあらわれている関数は、実際の戻り値の型がvoid型（返り値を返さない）になる。
この型述語は「関数が無事に終了すれば、引数名は型である」という意味。
無事に終了しない場合は例えば例外による脱出などが起きる場合がある。
返り値ではなｋ例外の有無で判定結果を表すタイプの関数に型を付ける場合に便利。

```
function assertHuman(value: any): asserts value is Human {
  if (value === null) {
    throw new Error('given value is null or undefined');
  };

  if (
    value.type !== "Human" ||
    typeof value.name !== "string" ||
    typeof value.age !== "number"
  ) {
    throw new Error('given value is not a human');
  };
};
```

この関数では、与えられた値がHumanを満たすかをチェックし、満たさなければthrowでエラーを発生させる。
ユースケースとしては下記のようになる

```
function checkAndUseHuman(value: unknown) {
  assertHuman(value);
  // この行以降、valueはHuman型になる
  const name = value.name;
}
```

checkAndUseHuman関数では、最初にassertHuman関数を呼び出すことでvalueがHumanであることを確認している。




### 6.7.3 可変長タプル型
### 6.7.4 mapped types
### 6.7.5 conditional types
### 6.7.6 組み込みの型を使いこなす

EOF