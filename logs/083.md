# 8 非同期処理
## 8.3 Promiseを使う
PromiseとはES2015で追加された非同期処理のための機能
非同期処理では「終わったあとに何するのか」が不可欠となっている
コールバック関数ベースの非同期処理では、非同期処理を実行する関数にコールバック関数を渡していたが、Promiseベースの非同期処理では、非同期処理を行う関数は関数を受け取らずPromiseオブジェクトを返すようになっている
そのPromiseオブジェクトに対して終わったあとに行う処理を表す関数を登録する

### 8.3.1 Promise版の fs を使ってみる

```
import { readFile } from "fs/promises";

const p = readFile("foo.txt", "utf8");

p.then((data) => {
  console.log(data);
});
```

p の型は  Promise<string> になっている。このように、Promiseベースの非同期処理を行う関数はPromiseオブジェクトを返す。
Promiseオブジェクトは Promise<T> という方と持ち、型としては型引数を1つもっていて、今回の Promise<string> は「string型の結果を持つPromiseオブジェクト」という意味になる。

例のように Promiseオブジェクトは　 then メソッドを持ち、引数としてコールバック関数を受け取る。渡されたコールバック関数はPromiseオブジェクトが示す非同期処理が完了した時点で呼び出される。

従来のコールバック関数を渡すこととの違いとして「非同期処理を行う関数にコールバック関数を直接渡す」という処理から「非同期処理を行う関数はPromiseオブジェクトを返す」「返されたPrommiseオブジェクトにthenでコールバック関数を返す」という2段階に分離されたことになる。これによって抽象的、統一的に非同期処理を表せるというのがPromiseの特徴です。

Promiseの結果が定まることをPromiseの解決(settlement)と呼び、Promiseが解決されるとthenのコールバック関数が呼び出される。
※Promiseには resolve という概念もあり、こちらを解決とすることもあるが、説明は省略する
https://qiita.com/uhyo/items/a9f6e70f43287cc0f52e

コールバック関数に対してPromiseオブジェクトを挟むことによるメリットとして、コールバック関数を直接渡す方式だと、引数のどこに渡す必要があるかなど都度調べる必要があり、コストが高かった。
一方でPromiseベースであれば常にPromiseオブジェクトが返されることが決まっており、結果も「Promiseの解決」という共通のインターフェースを通して行える。


また、PromiseベースAPIの場合、実際に非同期処理が始まるのは度のタイミングか、ということについては、上の例を利用すると「readFileを呼び出した瞬間に始まっており、Promiseオブジェクトが返り値として返された段階で既に始まっている」が回答になる（＝then が登録されたときではない）


### 8.3.2 コールバック関数の登録とエラー処理（１）











eof
