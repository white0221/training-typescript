# 8 非同期処理
## 8.2 コールバック処理による非同期処理の扱い
非同期処理を扱う方法で原始的なコールバック関数。
のちにPromiseが出現するまでは一般的だった。

### 8.2.1 コールバック関数とは
コールバック関数とは、非同期処理が終わった時に呼び出される関数のこと。

非同期処理実行中は、その処理の終了を待たずにプログラムの実行は次へと進むため、非同期処理の実行の終了を検知する手段が必要になる。
それが「関数を呼び出してもらう事」となり、この関数がコールバック関数。

コールバック関数を用いる場合、非同期処理の実行開始時に「終了した呼び出される関数」を登録しておくことで、完了したらその関数が呼ばれることになる。

```
console.log("1, start");
readFile("TextFile.txt", (data) => {
  console.log("3, read finish");
});
console.log("2, reading...");
```

readFile関数の第2引数に関数を渡しているこれが、コールバック関数。
実行完了時に呼ばれるもののため、コールバック関数の引数には data（実行結果）が伴っている。


### 8.2.2 タイマーの例

非同期処理のほかの例としてタイマーを挙げる
TypeScriptではsetTimeoutという関数があり、この関数を通してタイマーを使用できる

```
setTimeout(() => {
  console.log("start timer");
}, 3000);
console.log("timer is running");
```

setTimeoutの第1引数にはコールバック関数を、第2引数には数値（タイマー起動までのミリ秒）を指定する
実行すると、即座に「timer is running」と表示され、その3秒後に「start timer」と表示されることになる



### 8.2.3 fsモジュールによるファイル操作の例



### 8.2.4 同期処理と非同期処理の順序

同期的に執行中のプログラムに非同期処理が

同期的にの実行中のプログラムとはプログラムが書いてある通りに上から実行されている状態で、この状態で非同期処理が完了しても、同期的に実行中のプログラムが中断してコールバック関数が呼び出されることはない
その場合、同期的な実行が全部終了してからコールバック関数が呼び出される

```
import { performance } from "perf_hooks";

setTimeout(() => {
  console.log("called timer");
}, 100);

const startTime = performance.now()
let count = 0;
while(performance.now() - startTime < 1000) {
  count++;
}

console.log(count);
```

このプログラムはまずsetTimeoutで100ミリ秒後に完了するタイマーを設定して、コールバック関数が呼ばれるようにしており、startTimeから1秒間経過するまでの間に何度ループできるかを数えて表示するものになっている

このプログラムを実行すると、筆者の環境で700万回程度ループした

```
7112412
called timer
```

タイマーのコールバックより先にcountの値が出力されており、1秒かかる処理よりも100ミリ秒の処理のほうが遅く表示されておる

理由は「同期的に実行中のプログラムに非同期処理が割り込むことはない」という特性によるもの





EOF
